"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9263],{3905:(n,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>f});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function d(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},s=Object.keys(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var i=r.createContext({}),l=function(n){var e=r.useContext(i),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=l(n.components);return r.createElement(i.Provider,{value:e},n.children)},p="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,s=n.originalType,i=n.parentName,c=d(n,["components","mdxType","originalType","parentName"]),p=l(t),u=a,f=p["".concat(i,".").concat(u)]||p[u]||m[u]||s;return t?r.createElement(f,o(o({ref:e},c),{},{components:t})):r.createElement(f,o({ref:e},c))}));function f(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var s=t.length,o=new Array(s);o[0]=u;var d={};for(var i in e)hasOwnProperty.call(e,i)&&(d[i]=e[i]);d.originalType=n,d[p]="string"==typeof n?n:a,o[1]=d;for(var l=2;l<s;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1855:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const s={},o="Token",d={unversionedId:"examples/Terraswap/TerraswapToken",id:"examples/Terraswap/TerraswapToken",title:"Token",description:"",source:"@site/docs/examples/Terraswap/TerraswapToken.mdx",sourceDirName:"examples/Terraswap",slug:"/examples/Terraswap/TerraswapToken",permalink:"/docs/examples/Terraswap/TerraswapToken",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/Terraswap/TerraswapToken.mdx",tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Pair",permalink:"/docs/examples/Terraswap/TerraswapPair"}},i={},l=[],c={toc:l},p="wrapper";function m(n){let{components:e,...t}=n;return(0,a.kt)(p,(0,r.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"token"},"Token"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cwscript",metastring:"showLineNumbers",showLineNumbers:!0},'contract TerraswapToken implements CW20 {\n\n  event Transfer(from: Address, to: Address, amount: Int)\n  event Burn(from: Address, amount: Int)\n  event Mint(to: Address, amount: Int)\n  event Send(from: Address, to: Address, amount: Int)\n  event IncreaseAllowance(owner: Address, spender: Address, amount: Int)\n  event DecreaseAllowance(owner: Address, spender: Address, amount: Int)\n  event TransferFrom(from: Address, to: Address, by: Address, amount: Int)\n  event BurnFrom(from: Address, by: Address, amount: Int)\n  event Log(from: Address, to: Address, by: Address, amount: Int)\n\n  error InvalidZeroAmount()\n  error Unauthorized()\n\n  struct Timestamp(value: U64)\n\n  enum Expiration {\n    #Never\n    #AtTime(at: U64)\n    #AtHeight(at: Timestamp)\n  }\n\n  struct MinterData {\n    minter: Address,\n    cap?: U128\n  }\n\n  struct TokenInfo {\n     name: String,\n     symbol: String,\n     decimals: U8,\n     total_supply: U128,\n     mint?: MinterData\n  }\n\n  struct AllowanceResponse {\n    allowance: U128,\n    expires: Expiration\n  }\n\n  state {\n    token_info: TokenInfo\n    balances[owner: Address]: Int = 0\n    allowances[owner: Address, spender: Address]: AllowanceResponse? = None\n  }\n\n  fn validate_accounts!(accounts: CW20.Coin[]) {\n    let addresses = [];\n    for { address } in accounts {\n      if (address in addresses) {\n        fail! DuplicateInitialBalanceAddress(address);\n      }\n      addresses.push(address)\n    }\n  }\n\n  fn create_accounts!($state, accounts: CW20.Coin[]) -> Int {\n    let total_supply = 0\n    for row in accounts {\n      let addr = Address!(row.address)\n      $state.balances[addr] = row.amount\n      total_supply += row.amount\n    }\n    return total_supply\n  }\n\n  #instantiate(\n    name: String,\n    symbol: String,\n    decimals: U8,\n    initial_balances: CW20.Coin[],\n    mint?: MinterData\n  ) {\n    validate_accounts!(initial_balances)\n    let total_supply = create_accounts!($state, initial_balances)\n    if mint?.cap? and total_supply > mint.cap {\n      fail! "Initial supply greater than cap";\n    }\n    if mint? {\n      let mint = MinterData(Address!(mint.minter), mint.cap)\n    }\n    $state.token_info = TokenInfo(name, symbol, decimals, total_supply, mint)\n  }\n\n  exec #transfer(recipient: String, amount: Int) {\n    if amount == 0 {\n      fail! InvalidZeroAmount();\n    }\n\n    let rcpt_addr = Address!(recipient)\n\n    $state.balances[$info.sender] -= amount\n    $state.balances[rcpt_addr] += amount\n\n    emit Transfer($info.sender, Address!(recipient), amount)\n  }\n\n  exec #Burn(amount: Int) {\n    if amount == 0 {\n      fail! InvalidZeroAmount();\n    }\n    $state.balances[info.sender] -= amount\n    $state.token_info.total_supply -= amount\n\n    emit Burn($info.sender, amount)\n  }\n\n  exec #Mint(recipient: String, amount: Int) {\n    if amount == 0 {\n      fail! InvalidZeroAmount();\n    }\n\n    let config = $state.config\n\n    if config.mint!.minter != $info.sender {\n      fail! Unauthorized();\n    }\n\n    config.total_supply += amount\n    let limit = config.cap\n\n    if limit? and config.total_supply > limit {\n      fail! CannotExceedCap();\n    }\n\n    $state.token_info = $state.config\n    let rcpt_addr = Address!(recipient)\n    $state.balances[rcpt_addr] += amount\n\n    emit Mint(recipient, amount)\n  }\n\n\n  exec #send(contract: String, amount: Int, msg: Binary) {\n    if amount == 0 {\n      fail! InvalidZeroAmount();\n    }\n\n    let rcpt_addr = Address!(contract)\n    $state.balances[$info.sender] -= amount\n    $state.balances[rcpt_addr] += amount\n\n    emit Send($info.sender, contract, amount)\n  }\n\n  exec #increase_allowance(\n    spender: String,\n    amount: Int,\n    expires?: Expiration\n  ) {\n\n    let spender_addr = Address!(spender)\n    if spender_addr == $info.sender {\n      fail! CannotSetOwnAccount();\n    }\n\n    let allow = $state.allowances[env.sender, spender_addr]\n    if expires? {\n      allow.expires = expires\n    }\n\n    allow.allowance += amount\n    $state.allowance[$info.sender, spender_addr] = allow\n    emit IncreaseAllowance($info.sender, spender, amount)\n  }\n\n  exec #decrease_allowance(spender: String, amount: Int, expires?: Expiration) {\n    let spender_addr = Address!(spender)\n    if spender_addr == $info.sender {\n      fail! CannotSetOwnAccount();\n    }\n\n    let allowance = $state.allowances[$info.sender, spender_addr]\n\n    if amount < allowance.allowance {\n      allowance.allowance -= amount\n      if expires? {\n        allowance.expires = expires\n      }\n      $state.allowances[$info.sender, spender_addr] = allowance\n    } else {\n      $state.allowances[$info.sender, spender_addr]::remove!()\n    }\n\n    emit DecreaseAllowance($info.sender, spender, amount)\n  }\n\n  exec #transfer_from(owner: String, recipient: String, amount: Int) {\n    let rcpt_addr = Address!(recipient)\n    let owner_addr = Address!(owner)\n\n    deduct_allowance!(owner_addr, $info.sender, $env.block, amount)\n    $state.balances[owner_addr] -= amount\n    $state.balances[rcpt_addr] += amount\n\n    emit TransferFrom(owner, recipient, $info.sender, amount)\n  }\n\n  exec #burn_from(owner: String, amount: Int) {\n    let owner_addr = Address!(owner)\n    deduct_allowance!(owner_addr, $info.sender, $env.block, amount)\n\n    $state.balances[owner_addr]::update!(|s| s.checked_sub!(amount))\n    $state.token_info.total_supply -= amount\n\n    emit BurnFrom(owner, $info.sender, amount)\n  }\n\n  exec #send_from(owner: String, contract: String, amount: Int, msg: Binary) {\n    let rcpt_addr = Address!(contract)\n    let owner_addr = Address!(owner)\n\n    deduct_allowance!(owner_addr, $info.sender, $env.block, amount)\n    $state.balances[owner_addr] -= amount\n    $state.balances[rcpt_addr] += amount\n\n    emit SendFrom(owner, contract, $msg.sender, amount)\n    exec! $.#send_from(sender, amount, msg)\n  }\n\n  query #balance(address: String) {\n    let address = Address!(address)\n    let balance = state.balances[address]\n\n    return {\n      balance\n    }\n  }\n\n  query #token_info() {\n    return state.token_info\n  }\n\n  query #minter() {\n    return state.token_info.mint\n  }\n\n  query #allowance(owner: String, spender: String) {\n    let owner_addr = Address!(owner)\n    let spender_addr = Address!(spender)\n    return $state.allowances[owner_addr, spender_addr]\n  }\n\n  query #all_allowances(owner: String, start_after?: String, limit?: Int) -> AllowanceResponse {\n    let limit = (limit ?? DEFAULT_LIMIT).min(MAX_LIMIT)\n    let allowances = $state.allowances[owner_addr]::range(start, None)\n      .take(limit)\n      .map(|item| item.map(|addr, allow| AllowanceInfo {\n          spender: addr,\n          allowance: allow.allowance,\n          expires: allow.expires\n       }))\n    return {\n      allowances\n    }\n  }\n}\n')))}m.isMDXComponent=!0}}]);