"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1472],{3905:(n,e,t)=>{t.d(e,{Zo:()=>m,kt:()=>R});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function p(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function E(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var s=r.createContext({}),o=function(n){var e=r.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):p(p({},e),n)),t},m=function(n){var e=o(n.components);return r.createElement(s.Provider,{value:e},n.children)},l="mdxType",c={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},A=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,s=n.parentName,m=E(n,["components","mdxType","originalType","parentName"]),l=o(t),A=a,R=l["".concat(s,".").concat(A)]||l[A]||c[A]||i;return t?r.createElement(R,p(p({ref:e},m),{},{components:t})):r.createElement(R,p({ref:e},m))}));function R(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,p=new Array(i);p[0]=A;var E={};for(var s in e)hasOwnProperty.call(e,s)&&(E[s]=e[s]);E.originalType=n,E[l]="string"==typeof n?n:a,p[1]=E;for(var o=2;o<i;o++)p[o]=t[o];return r.createElement.apply(null,p)}return r.createElement.apply(null,t)}A.displayName="MDXCreateElement"},1852:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>p,default:()=>c,frontMatter:()=>i,metadata:()=>E,toc:()=>o});var r=t(7462),a=(t(7294),t(3905));const i={sidebar_position:1},p="Grammar",E={unversionedId:"lang/grammar/grammar",id:"lang/grammar/grammar",title:"Grammar",description:"The following code listing is the ANTLR4 grammar for the CWScript language, which is used to generate the initial parser in the CWScript compiler.",source:"@site/docs/lang/grammar/grammar.mdx",sourceDirName:"lang/grammar",slug:"/lang/grammar/",permalink:"/docs/lang/grammar/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/lang/grammar/grammar.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"langSidebar",next:{title:"Context Variables",permalink:"/docs/lang/context-vars"}},s={},o=[],m={toc:o},l="wrapper";function c(n){let{components:e,...t}=n;return(0,a.kt)(l,(0,r.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"grammar"},"Grammar"),(0,a.kt)("p",null,"The following code listing is the ",(0,a.kt)("a",{parentName:"p",href:"https://antlr.org"},"ANTLR4")," grammar for the CWScript language, which is used to generate the initial parser in the CWScript compiler.\nNote that the parser described by this grammar intentionally parses a relaxed superset of the actual CWScript language; this is to extract as much information\nto report diagnostics. The compiler performs additional validations to ensure that the program is valid."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-antlr4"},"grammar CWScript;\n\n// Files contain 1 or more topLevelStatement\nsourceFile: (topLevelStmt | SEMI)* EOF;\n\ntopLevelStmt:\n    importStmt | contractDefn | interfaceDefn | stmt;\n\n// Contract Block\ncontractDefn:\n    (ann+=annot)*\n    CONTRACT (name = ident) (\n        EXTENDS (base=typePath)\n    )? (IMPLEMENTS (interfaces+=typePath))? (body=contractBlock);\n\n// Interface\ninterfaceDefn:\n    (ann+=annot)*\n    INTERFACE (name = ident) (\n        EXTENDS (base=typePath)\n    )? (body=contractBlock);\n\ncontractBlock: LBRACE (body+=contractItem)* RBRACE;\n\n// Import Statement\nimportStmt:\n    // import * from \"...\"\n    IMPORT MUL FROM (src = StringLiteral) # ImportAllStmt\n    // import { a } from \"...\"\n    | IMPORT (\n        (LBRACE (items += ident) (COMMA items += ident)* RBRACE)\n    ) FROM (src = StringLiteral) # ImportItemsStmt;\n\ncontractItem:\n    typeDefn\n    | constStmt_\n    | fnDefn\n    | errorDefn\n    | errorDefnBlock\n    | eventDefn\n    | eventDefnBlock\n    | stateDefnBlock\n    | instantiateDefn\n    | instantiateDecl\n    | execDefn\n    | execDecl\n    | queryDefn\n    | queryDefn\n    | queryDecl\n    | replyDefn;\n\n// a[?] : b [= c]\nparam: (ann+=annot)* (name = ident) (optional=QUEST)? (COLON (ty = typeExpr) (EQ default=expr)?)?;\nparamList: param (COMMA param)*;\nfnParams:\n    LPAREN ((params+=param) (COMMA params+=param)*)? RPAREN;\n\nstructDefn_fn: (name = ident) (params=fnParams);\n\n// Errors\n// error Item( ... )\nerrorDefn: ERROR defn=structDefn_fn;\nerrorDefnBlock:\n    ERROR LBRACE (\n        (defns+=structDefn_fn) (COMMA defns+=structDefn_fn)* COMMA?\n    )? RBRACE;\n\n// Events\neventDefn: EVENT structDefn_fn;\neventDefnBlock:\n    EVENT LBRACE (\n        (defns+=structDefn_fn) (COMMA defns+=structDefn_fn)* COMMA?\n    )? RBRACE;\n\n// State\nstateDefnBlock:\n    STATE LBRACE (\n        defns += stateDefn\n    )* RBRACE;\nstateDefn:\n    (name=ident) COLON (ty=typeExpr) (EQ (default=expr))? # StateDefn_Item\n    | (name=ident) LBRACK (mapKeys+=mapKeyDefn) (COMMA (mapKeys+=mapKeyDefn))* RBRACK COLON (ty=typeExpr) (EQ (default=expr))? # StateDefn_Map;\n\nmapKeyDefn: ((name=ident) COLON)? (ty=typeExpr);\n\n// Instantiate\ninstantiateDefn: HASH INSTANTIATE params=fnParams body=block;\ninstantiateDecl: HASH INSTANTIATE params=fnParams;\n\n// Exec Defn\nexecDefn:\n    EXEC (tup=MUL)? HASH name=ident params=fnParams body=block;\n\nexecDecl: EXEC (tup=MUL)? HASH name=ident params=fnParams;\n\n// query.mdx Defn\nqueryDefn: QUERY HASH name=ident params=fnParams (ARROW retTy=typeExpr)? body=block;\nqueryDecl: QUERY HASH name=ident params=fnParams (ARROW retTy=typeExpr)?;\n\n// Reply Defn\nreplyDefn: REPLY (DOT on=ident)? name=ident params=fnParams body=block;\n\n// Enum\nenumDefn: ENUM (name = ident) LBRACE variants+=variant_ ((variants+=variant_) COMMA?)* RBRACE;\nvariant_: variant_struct | variant_unit;\nvariant_struct: HASH (name = ident) LPAREN (members=paramList)? RPAREN\n    | HASH (name = ident) LBRACE (members=paramList)? RBRACE;\n\nvariant_unit: HASH (name = ident);\n\n// Type Expressions\ntypeExpr:\n    LT typeExpr GT                                                    # TypeAppT\n    | typePath # PathT\n    | typeVariant # VariantT\n    | typeLens # LensT\n    | fnType # FnT\n    | typeExpr QUEST                                                 # OptionT\n    | typeExpr LBRACK (len=IntLiteral)? RBRACK                       # ListT\n    | LBRACK (items+=typeExpr (COMMA items+=typeExpr)*)? RBRACK      # TupleT\n    | typePath LT (args+=typeArg) (COMMA args+=typeArg)* GT          # ParamzdT\n    | typeDefn                                                       # DefnT;\n\ntypeArg: (name=ident EQ)? (value=typeExpr);\nfnType: FN (fallible=BANG)? LPAREN (params=paramList)? RPAREN ARROW retTy=typeExpr;\n\ntypeLens: scope=(INSTANTIATE | EXEC | QUERY | MUT) typePath;\ntypePath: (segments+=ident) (DOT segments+=ident)*;\ntypeVariant: typePath (LPAREN expr RPAREN)? (DOT HASH variant=ident);\ntypeDefn: structDefn | enumDefn | typeAliasDefn;\n\nstructDefn:\n    STRUCT (name=ident)? LPAREN ((members+=param) (COMMA (members+=param))*)? RPAREN\n    | STRUCT (name=ident)? LBRACE ((members+=param) (COMMA (members+=param))* COMMA?) RBRACE;\n\ntypeAliasDefn: TYPE (name = ident) EQ (value = typeExpr);\n\n// Functions\nfnDefn: FN (name = ident) (fallible=BANG)? params=fnParams (ARROW retTy=typeExpr)? body=block;\n\nannot: AT (isTag=AT)? (path = typePath) (LPAREN (args+=arg)? RPAREN)?;\n\ncallOptions: (LBRACE ((memberVal) (COMMA memberVal)* COMMA?)? RBRACE);\n\n// Statements\nstmt: annot block # AnnotBlockStmt\n    | (ann+=annot)* debugStmt_      # DebugStmt\n    | (ann+=annot)* letStmt_           # LetStmt\n    | (ann+=annot)* constStmt_     # ConstStmt\n    | (ann+=annot)* assignStmt_     # AssignStmt\n    | (ann+=annot)* ifStmt_         # IfStmt\n    | (ann+=annot)* forStmt_        # ForStmt\n    | (ann+=annot)* (defer=DEFER)? EXEC_NOW expr (options=callOptions)? # ExecStmt\n    | (ann+=annot)* (defer=DEFER)? DELEGATE_EXEC HASH expr # DelegateExecStmt\n    | (ann+=annot)* (defer=DEFER)? INSTANTIATE_NOW (new=HASH)? expr (options=callOptions)? # InstantiateStmt\n    | (ann+=annot)* (defer=DEFER)? EMIT expr       # EmitStmt\n    | (ann+=annot)* RETURN expr      # ReturnStmt\n    | (ann+=annot)* FAIL expr        # FailStmt\n    | (ann+=annot)* expr             # ExprStmt;\n\ndebugStmt_: DEBUG (block | stmt)?;\n\nletStmt_: LET let_binding (EQ expr)?;\nconstStmt_: CONST ident EQ expr;\n\nidentBinding_: (name=ident) (COLON ty = typeExpr)?;\nlet_binding:\n    identBinding_    # IdentBinding\n    | LBRACE (bindings+=identBinding_) (COMMA )* RBRACE            # StructBinding\n    | LBRACK (bindings+=identBinding_) (COMMA bindings+=identBinding_)* RBRACK            # TupleBinding;\n\n\nassignStmt_:\n    (lhs = assignLHS) (assignOp = (\n        EQ\n        | PLUS_EQ\n        | MINUS_EQ\n        | MUL_EQ\n        | DIV_EQ\n        | MOD_EQ\n    )) (rhs = expr);\n\nassignLHS:\n    symbol=ident # IdentLHS\n    | (obj = expr) DOT (member = ident) # DotLHS\n    | (obj = expr) LBRACK (args+=expr) (COMMA args+=expr)* RBRACK  # IndexLHS;\n\n// Expressions\nexpr:\n    LPAREN expr RPAREN        # GroupedExpr\n    | expr (unwrap=(BANG | QUEST))? DOT (member=ident) # DotExpr\n    | expr AS ty=typeExpr    # AsExpr\n    | expr LBRACK (args+=arg) (COMMA args+=arg)* RBRACK # IndexExpr\n    | expr D_COLON (member=ident) # DColonExpr\n    | typeExpr D_COLON (member=ident) # TypeDColonExpr\n    | expr fallible=BANG? LPAREN ((args+=arg) (COMMA args+=arg)*)? RPAREN # FnCallExpr\n    | typeExpr fallible=BANG? LPAREN ((args+=arg) (COMMA args+=arg)*)? RPAREN # TypeFnCallExpr\n    | expr (op = (MUL | DIV | MOD)) (rhs=expr)          # MulExpr\n    | expr (op = (PLUS | MINUS)) (rhs=expr)             # AddExpr\n    | expr (op = (LT | GT | LT_EQ | GT_EQ)) (rhs=expr)  # CompExpr\n    | expr (op = (EQ_EQ | NEQ)) (rhs=expr)  # EqExpr\n    | expr QUEST # NoneCheckExpr\n    | expr IS (negative=NOT)? (rhs=typeExpr) # IsExpr\n    | expr IN (rhs=expr)                  # InExpr\n    | expr D_QUEST (rhs=expr) # ShortTryExpr\n    | tryCatchElseExpr_ # TryCatchElseExpr\n    | NOT expr # NotExpr\n    | expr AND (rhs=expr)                 # AndExpr\n    | expr OR (rhs=expr)                  # OrExpr\n    | ifStmt_ # IfExpr\n    | QUERY_NOW expr # QueryNowExpr\n    | FAIL expr # FailExpr\n    | closure # ClosureExpr\n    | LBRACK ((items+=expr) (COMMA (items+=expr))*)? RBRACK # TupleExpr\n    | typeExpr? LBRACE ((members+=memberVal) (COMMA members+=memberVal)* COMMA?)? RBRACE # StructExpr\n    | typeVariant # UnitVariantExpr\n    | literal # LiteralExpr\n    | ident # IdentExpr\n    | expr TILDE # Grouped2Expr;\n\nclosureParams: BAR ((params+=param) (COMMA (params+=param))*)? BAR;\n\nclosure:\n    (fallible=BANG)? (params=closureParams) (((ARROW retTy=typeExpr)? block) | stmt);\n\nblock: LBRACE ((body+=stmt) | SEMI)* RBRACE;\ntryCatchElseExpr_: TRY (body=block) (catches+=catchClause)* (else_=elseClause)?;\ncatchClause:\n    CATCH (ty=typeExpr) (body=block) # Catch\n    | CATCH (name=ident) (COLON (ty=typeExpr)) (body=block) # CatchBind;\n\narg: ((name=ident) EQ)? (value=expr);\nmemberVal:\n    (name = ident) (COLON (value = expr))?;\n\n// Literal Expressions\nliteral:\n    StringLiteral                               # StringLit\n    | IntLiteral                                # IntLit\n    | DecLiteral                                # DecLit\n    | BoolLiteral                               # BoolLit\n    | NONE                               # NoneLit;\n\nifStmt_: IF (pred = expr) (body=block) (else_=elseClause)?;\nelseClause: ELSE block | ELSE stmt;\n\n// For Loops\nforStmt_:\n    FOR (binding=let_binding) IN (iter=expr) body=block;\n\nident: (Ident | reservedKeyword);\n\nreservedKeyword:\n    CONTRACT\n    | INTERFACE\n    | IMPORT\n    | IMPLEMENTS\n    | EXTENDS\n    | ERROR\n    | EVENT\n    | INSTANTIATE\n    | EXEC\n    | QUERY\n    | REPLY\n    | FOR\n    | IN\n    | FROM\n    | STATE\n    | IF\n    | FN\n    | ELSE\n    | AND\n    | OR\n    | TRUE\n    | FALSE\n    | LET\n    | STRUCT\n    | ENUM\n    | TYPE\n    | EMIT;\n\n//region <LEXER-RULES>\n\n// KEYWORDS\nDEBUG: 'debug!';\nCONTRACT: 'contract';\nINTERFACE: 'interface';\nIMPORT: 'import';\nIMPLEMENTS: 'implements';\nEXTENDS: 'extends';\nERROR: 'error';\nEVENT: 'event';\nDEFER: 'defer';\nINSTANTIATE_NOW: 'instantiate!';\nEXEC_NOW: 'exec!';\nQUERY_NOW: 'query!';\nDELEGATE_EXEC: 'delegate_exec!';\nINSTANTIATE: 'instantiate';\nEXEC: 'exec';\nQUERY: 'query';\nREPLY: 'reply';\nFOR: 'for';\nIN: 'in';\nFROM: 'from';\nSTATE: 'state';\nIF: 'if';\nIS: 'is';\nTRY: 'try';\nCATCH: 'catch';\nELSE: 'else';\nNOT: 'not';\nNONE: 'None';\nMUT: 'mut';\nAND: 'and';\nOR: 'or';\nTRUE: 'true';\nFALSE: 'false';\nFN: 'fn';\nLET: 'let';\nCONST: 'const';\nFAIL: 'fail!';\nRETURN: 'return';\nSTRUCT: 'struct';\nENUM: 'enum';\nTYPE: 'type';\nEMIT: 'emit';\nAS: 'as';\n\n\n// PUNCTUATION\nTILDE: '~';\nLPAREN: '(';\nRPAREN: ')';\nLBRACK: '[';\nRBRACK: ']';\nLBRACE: '{';\nRBRACE: '}';\nDOT: '.';\nCOMMA: ',';\nD_QUEST: '??';\nQUEST: '?';\nBANG: '!';\nSEMI: ';';\nCOLON: ':';\nD_COLON: '::';\nHASH: '#';\nAT: '@';\nAMP: '&';\nARROW: '->';\nFAT_ARROW: '=>';\nBAR: '|';\nS_QUOTE: '\\'';\nD_QUOTE: '\"';\nEQ: '='; // OPS\nEQ_EQ: '==';\nNEQ: '!=';\nPLUS: '+';\nPLUS_EQ: '+=';\nMINUS: '-';\nMINUS_EQ: '-=';\nMUL: '*';\nMUL_EQ: '*=';\nDIV: '/';\nDIV_EQ: '/=';\nMOD: '%';\nMOD_EQ: '%=';\nLT: '<';\nLT_EQ: '<=';\nGT: '>';\nGT_EQ: '>=';\nPOW: '**';\n\n// Identifiers\nIdent: [_a-zA-Z$][_a-zA-Z0-9]*;\n\n// Strings\nStringLiteral: D_QUOTE DoubleQuotedStringCharacter* D_QUOTE;\nfragment DoubleQuotedStringCharacter: ~[\"\\r\\n\\\\] | ('\\\\' .);\n\n// Numbers\nIntLiteral: DecimalDigits;\nDecLiteral: (DecimalDigits? DOT DecimalDigits);\nfragment DecimalDigits: [0-9] ( '_'? [0-9])*;\n\n// Bool\nBoolLiteral: TRUE | FALSE;\n\nLINE_COMMENT: '//' ~[\\r\\n]* -> channel(HIDDEN);\nBLOCK_COMMENT: '/*' .*? '*/' -> channel(HIDDEN);\n\n// Whitespace\nWS: [\\r\\n\\t ] -> channel(HIDDEN);\n\n//endregion <LEXER-RULES>\n")))}c.isMDXComponent=!0}}]);