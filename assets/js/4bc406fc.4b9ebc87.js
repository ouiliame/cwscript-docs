"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[728],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>m});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},f=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},_="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,f=i(e,["components","mdxType","originalType","parentName"]),_=p(t),d=a,m=_["".concat(l,".").concat(d)]||_[d]||c[d]||s;return t?o.createElement(m,r(r({ref:n},f),{},{components:t})):o.createElement(m,r({ref:n},f))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,r=new Array(s);r[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[_]="string"==typeof e?e:a,r[1]=i;for(var p=2;p<s;p++)r[p]=t[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5097:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var o=t(7462),a=(t(7294),t(3905));const s={},r="Pair",i={unversionedId:"examples/Terraswap/TerraswapPair",id:"examples/Terraswap/TerraswapPair",title:"Pair",description:"",source:"@site/docs/examples/Terraswap/TerraswapPair.mdx",sourceDirName:"examples/Terraswap",slug:"/examples/Terraswap/TerraswapPair",permalink:"/cwscript-docs/docs/examples/Terraswap/TerraswapPair",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/Terraswap/TerraswapPair.mdx",tags:[],version:"current",frontMatter:{},sidebar:"examplesSidebar",previous:{title:"Factory",permalink:"/cwscript-docs/docs/examples/Terraswap/TerraswapFactory"},next:{title:"Token",permalink:"/cwscript-docs/docs/examples/Terraswap/TerraswapToken"}},l={},p=[],f={toc:p},_="wrapper";function c(e){let{components:n,...t}=e;return(0,a.kt)(_,(0,o.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pair"},"Pair"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cwscript",metastring:"showLineNumbers",showLineNumbers:!0},'contract TerraswapPair {\n\n  state {\n    pair_info: PairInfo\n  }\n\n  reply.success register_pair() {\n\n    let { tmp_pair_info } = $state\n    let response = Wasm.#instantiate::parse_response!($data)\n    let response = instantiate #CW20::parse_response!($data)\n\n    instantiate! #CW20(1, 2, 3) {\n        code_id: 1,\n        label: "admin"\n    }\n\n    let pair_contract = response.address\n    let pair_info = query! TerraswapPair(pair_contract).#pair() ~.token_supply\n\n    $state.pairs = PairInfo(\n      Address.Canonical!(pair_info.liquidity_token),\n      Address.Canonical!(pair_info.liquidity_token),\n      asset_infos=tmp_pair_info.asset_infos,\n      asset_decimals=tmp_pair_info.asset_decimals\n    )\n  }\n\n  #instantiate(\n    asset_infos: AssetInfo[2], // list of 2\n    token_code_id: U64,\n    asset_decimals: U8[2]\n  ) {\n    $state.pair_info = PairInfo {\n      contract_addr: $env.contract.address,\n      liquidity_token: Address.empty(),\n      asset_infos: [\n        String!(msg.asset_infos[0]),\n        String!(msg.asset_infos[1])\n      ]\n    }\n\n    @gas_limit(500000)\n    @reply.success(register_pairs)\n    instantiate! #CW20(\n      12, "terraswap liquidity token", "uLP", 6, [], MinterResponse($env.contract.address)\n    ) {\n      funds: "1000000uluna", // it\'s going to be like terra.js -- automatic conversion\n      label: "lp",\n      // msg: #CW20() ... otherwise we could put it here\n    }\n\n  }\n\n  exec *#receive(msg: CW20.receive) {\n    let msgbody = msg.msg\n    if msgbody is CW20.Hook.Swap {\n      let { belief_price, max_spread, to } = msg.msg\n      let authorized = false\n      let config = pair_info\n      for pool in pools {\n        if to is AssetInfo.Token {\n          if contract_addr == $info.sender {\n            authorized = true\n          }\n        }\n      }\n\n      if not authorized {\n        fail! Unauthorized()\n      }\n\n      let to_addr = if to? {\n        Address.validate!(to)\n      } else none\n\n      delegate_exec! #swap(\n        Address(msg.sender),\n        Asset(AssetInfo.Token(contract_addr), msg.amount),\n        belief_price,\n        max_spread,\n        to_addr\n      )\n    } else if msgbody is CW20.Hook.WithdrawLiquidity {\n      let config = $state.pair_info\n      if sender != config.liquidity_token {\n        fail! Unauthorized()\n      }\n\n      let sender_addr = Address.validate!(msg.sender)\n      exec! #withdraw_liquidity(sender_addr, msg.amount)\n    }\n  }\n\n  fn query_pools($state, pair_info: PairInfo, addr: Address) {\n    pair_info.asset_infos.map!(|ai| Asset(ai, query_pool!($, ai, addr)))\n  }\n\n  fn query_pool!($state, asset_info: AssetInfo, addr: Address) -> U128 {\n    if asset_info is AssetInfo.Token {\n      let res = query! Bank.#balance(asset_info.contract_addr, $state.balance[addr])\n      res.balance\n    } else if asset_info is AssetInfo.NativeToken {\n      let res = query! Bank.#balance(addr, asset_info.denom)\n      res.amount.amount\n    } else {\n      0\n    }\n  }\n\n  fn assert_sent_native_token_balance!($state) {\n    for asset in assets {\n      if asset is AssetInfo.NativeToken {\n        let coin = $info.funds.find(|x| x.denom == denom)\n        if coin? {\n          if asset.amount != coin.amount {\n            fail! "Native token balance mismatch between the argument and the transferred"\n          }\n        }\n      } else {\n        if asset.amount != 0 {\n          fail! "Native token balance mismatch between the argument and the transferred"\n        }\n      }\n    }\n  }\n\n  exec #provide_liquidity(assets: Asset[2], slippage_tolerance?: Dec, receiver?: String) {\n    assert_sent_native_token_balance!($state)\n    let pair_info = $state.pair_info\n    let pools = $.query_pools!(pair_info, $env.contract.address)\n\n    let deposits = [\n      assets.find(|a| a.info == pools[0].info).map(|a| a.amount) ?? fail! "wrong asset info is given",\n      assets.find(|a| a.info == pools[1].info).map(|a| a.amount) ?? fail! "wrong asset info is given"\n    ]\n\n    for [i, pool] in pools.enumerate() {\n      if pool.info is AssetInfo.#Token {\n        let { contract_addr } = pool.info\n        $response.msgs += exec CW20(contract_addr)\n            .#transfer_from($info.sender, $env.contract.address, deposits[i])\n      } else {\n        pool.amount -= deposits[i]\n      }\n    }\n\n    let { liquidity_token } = pair_info\n    let total_share = query! $.token_info() ~ .total_supply\n\n    let share = if total_share == 0 {\n      let deposit0 = U256!(deposits[0])\n      let deposit1 = U256!(deposits[1])\n\n      let share = U128!(\n        Dec256.ratio!(deposit0 * deposit1, 1).sqrt() * U256!(1)\n      ) ?? fail! ConversionError()\n    } else {\n      U128.min(\n        deposits[0].multiply_ratio(total_share, pools[0].amount),\n        deposits[1].multiply_ratio(total_share, pools[1].amount)\n      )\n    }\n\n    if share == 0 {\n      fail! InvalidZeroAmount()\n    }\n\n    let receiver = receiver ?? $info.sender\n    emit ProvideLiquidity($info.sender, receiver, assets[0], assets[1], share)\n    exec! CW20(pair_info.liquidity_token).#mint(receiver, amount)\n  }\n\n  fn compute_swap!(offer_pool: U128, ask_pool: U128, offer_amount: U128) -> [U128, U128, U128] {\n    let offer_pool = U256!(offer_pool)\n    let ask_pool = U256!(ask_pool)\n    let offer_amount = U256!(offer_amount)\n\n    let commission_rate = Dec256!(COMMISSION_RATE)\n    let cp = offer_pool.mul!(ask_pool)\n    let return_amount = (\n      Dec256.ratio!(ask_pool, 1) - Dec256.ratio!(cp, offer_pool + offer_amount) * U256(1)\n    )\n\n    let spread_amount = (\n      offer_amount * Dec256.ratio!(ask_pool, offer_pool) - return_amount\n    )\n\n    let commission_amount = return_amount * commission_rate\n    let return_amount = return_amount - commission_amount\n    return [U128!(return_amount), U128!(spread_amount), U128!(commission_amount)]\n  }\n\n  exec #swap(\n    sender: Address,\n    offer_asset: Asset,\n    belief_price?: Dec,\n    max_spread?: Dec,\n    to?: Address\n  ) {\n    assert_sent_native_token_balance!($)\n    let pair_info = $state.pair_info\n    let pools = query_pools!(pair_info, $.env.contract.address)\n\n    let offer_pool: Asset\n    let ask_pool: Asset\n    let offer_decimal: U8\n    let ask_decimal: U8\n\n    if offer_asset.info == pools[0].info {\n      offer_pool = Asset(pools[0].info, pools[0].amount.checked_sub!(offer_asset.amount))\n      ask_pool = pools[1]\n      [offer_decimal, ask_decimal] = pair_info.asset_decimals\n    }\n\n    if offer_asset is AssetInfo.#NativeToken {\n      fail Unauthorized()\n    } else if offer_asset.info == pools[1].info {\n      offer_pool = Asset {\n        amount: pools[1].amount.checked_sub!(offer_asset.amount),\n        info: pools[1].info\n      }\n      ask_pool = pools[0]\n      [offer_decimal, ask_decimal] = [pair_info.asset_decimals[1], pair_info.asset_decimals[0]]\n    } else {\n      fail! AssetMismatch()\n    }\n\n    let offer_amount = offer_asset.amount\n    let [return_amount, spread_amount, commission_amount] = compute_swap!(offer_pool.amount, ask_pool.amount, offer_amount)\n\n    let return_asset = Asset(ask_pool.info, return_amount)\n    $.assert_max_spread!(belief_price, max_spread, offer_asset, return_asset, spread_amount, offer_decimal, ask_decimal)\n\n    let receiver = to ?? sender\n    if return_amount != 0 {\n      if return_asset is AssetInfo.#Token {\n        call Wasm.#execute(return_asset.contract_addr, CW20.transfer(recipient, amount))\n      } else {\n        call Wasm.#send(to_address, Coin(amount, denom))\n      }\n    }\n\n    emit Swap(sender, receiver, offer_asset.info, ask_pool.info, offer_amount, spread_amount, commission_amount)\n  }\n\n  query #pair() {\n    return $state.pair_info\n  }\n\n  query #pool() {\n    let { pair_info } = $state\n    let { contract_addr } = pair_info\n    let assets = query_pools!(pair_info, contract_addr)\n    let { total_share } = query! CW20(contract_addr).#token_info()\n    return {\n      assets, total_share\n    }\n  }\n\n  query #simulation(offer_asset: Asset) {\n    let pair_info = $state.pair_info\n    let { contract_addr } = pair_info\n\n    let pools = query_pools!(pair_info, contract_addr)\n    let offer_pool: Asset\n    let ask_pool: Asset\n\n    if offer_asset.info == pools[0] {\n      let [offer_pool, ask_pool] = [pools[0], pools[1]]\n    } else if offer_asset.info == pools[1] {\n      let [offer_pool, ask_pool] = [pools[1], pools[0]]\n    } else {\n      fail! AssetMismatch()\n    }\n\n    let [return_amount, spread_amount, commission_amount] = compute_swap!(\n      offer_pool.amount, ask_pool.amount, offer_asset.amount\n    )\n\n    return {\n      return_amount, spread_amount, commission_amount\n    }\n  }\n\n  query #reverse_simulation(ask_asset: Asset) {\n    let { contract_addr } = $state.pair_info\n\n    let pools = query_pools!($state, pair_info, contract_addr)\n    let offer_pool: Asset\n    let ask_pool: Asset\n\n    if ask_asset.info == pools[0] {\n      let [ask_pool, offer_pool] = [pools[0], pools[1]]\n    } else if ask_asset.info == pools[1] {\n      let [ask_pool, offer_pool] = [pools[1], pools[0]]\n    } else {\n      fail! AssetMismatch()\n    }\n\n    let [offer_amount, spread_amount, commission_amount] = compute_offer_amount!(\n      offer_pool.amount, ask_pool.amount, ask_asset.amount\n    )\n\n    return {\n      offer_amount, spread_amount, commission_amount\n    }\n  }\n}\n')))}c.isMDXComponent=!0}}]);